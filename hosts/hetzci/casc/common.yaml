appearance:
  pipelineGraphView:
    showGraphOnBuildPage: true
  themeManager:
    theme: "darkSystem" # follow system theme

jenkins:
  numExecutors: 4
  markupFormatter:
    rawHtml:
      disableSyntaxHighlighting: false
  log:
    recorders:
    - loggers:
      - name: "org.jenkinsci.plugins.github"
        level: "ALL"
      - name: "hudson.security.csrf.CrumbFilter"
        level: "SEVERE"
      name: "Debug"

unclassified:
  timestamper:
    allPipelines: true
  lockableResourcesManager:
    declaredResources:
    - name: "evaluator"
      description: "Nix evaluator lock"
    - name: "build-description"
      description: "Prevent parallel build description modifications"
    - name: "signing"
      description: "Prevent parallel signing operations through the pkcs11 proxy"

# https://plugins.jenkins.io/configuration-as-code-groovy/
groovy:
  # Keep stale-crumb polling noise out of systemd journal.
  - script: |
      import java.util.logging.Level
      import java.util.logging.Logger
      Logger.getLogger("hudson.security.csrf.CrumbFilter").setLevel(Level.SEVERE)
  # Load pipelines:
  - script: |
      import jenkins.model.*
      import org.jenkinsci.plugins.workflow.job.WorkflowJob
      import org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition
      import groovy.io.FileType
      println("Loading pipelines")
      def pipelines = new File("/etc/jenkins/pipelines/")
      pipelines.eachFile(FileType.FILES) { file ->
        if (!file.name.endsWith(".groovy")) {
          return
        }
        def pipelineName = file.name.substring(0, file.name.lastIndexOf('.'))
        println("Loading pipeline from: ${pipelineName}")
        def job = Jenkins.getInstance().getItemByFullName(pipelineName, WorkflowJob)
        if (job == null) {
          job = Jenkins.getInstance().createProject(WorkflowJob, pipelineName)
        }
        job.definition = new CpsFlowDefinition(file.text, true)
        job.save()
      }
  # Trigger all pipelines on jenkins service (re)start:
  - script: |
      import jenkins.model.*
      import hudson.model.*
      import hudson.security.ACL
      import hudson.security.ACLContext
      def reloadDelaySeconds = 10
      def params = new ParametersAction([ new StringParameterValue("RELOAD_ONLY", "true")])
      println("Scheduling pipeline reload in ${reloadDelaySeconds}s")
      Thread.start("pipeline-startup-reload") {
        // Background threads do not reliably inherit Jenkins SYSTEM auth context.
        // Use SYSTEM explicitly so job lookup/scheduling works during startup.
        ACLContext aclContext = ACL.as2(ACL.SYSTEM2)
        try {
          sleep(reloadDelaySeconds * 1000L)
          def jobs = Jenkins.getInstance().getAllItems(Job)
          println("Found ${jobs.size()} jobs for startup reload")
          for (job in jobs) {
            println("Triggering job: " + job.getName())
            def queueItem = job.scheduleBuild2(0, params)
            if (queueItem == null) {
              println("Skipped triggering job: ${job.getName()}")
            }
          }
        } catch (InterruptedException ignored) {
          Thread.currentThread().interrupt()
          println("Startup pipeline reload thread interrupted")
        } catch (Exception e) {
          println("Startup pipeline reload thread failed: ${e}")
          e.printStackTrace()
        } finally {
          aclContext.close()
        }
      }
